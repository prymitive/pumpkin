# custom_search - jeśli robić to co wtedy zwracać?

# Debug

# Statystyki

#  zrobić storage do wszystkich modeli, tak żeby 30 importów nie alokowało
#      30 pełnych fieldów a ino 1

# PasswordField - jak?
# b) StringField + metoda password() na modelu która działa tylko jak jest
#    field typu PasswordField w modelu i woła directory.mod_password_s(),
#    do tego kwargsy enc=(plain,md5,sha1) itd., encode2str zwróci str zakodowanego
#    przy użyciu odpowiedniej metody, sprawdzić czy nasze md5 == ldap md5

# DNField - jak zrobić?
# a) po prostu str
# b) instancja modelu - ale jakiego modelu? nie wiadomo w momencie definicji
#    modelu który ma zawierać DNField, nie ma jak tego przekazać potem
# c) custom_func generujący instancje modelu

# wyjątki zrobić

# delete()
# jak skasujemy obiekt z LDAP'a to trzeba zadbać żeby instancja była oznaczona
# jako _empty i _dn musi być wyczyszczony, czyli po delete() ma zadziałać:
# 1. save()
# 2. zmiana fieldów w _rdn_
# 3. set_parent()

# małe i duże litery są przez pumpkin'a rozróżnianie ale ldap je olewa

# ModelField i ModelListField - przechowuje dn'y innych obiektów, zwraca
# instancje model z podanej listy, tylko co ma zwracać jak dn wskazuje na obiekt
# który nie istnieje

# rekursywny delete?

# recursywny rename?

# catchall model? _object_class_ = '*'
